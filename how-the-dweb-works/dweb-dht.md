# dWeb's DHT
dWeb uses a `distributed hash table` (DHT) for storing the announcements of dDatabases (and other dDatabase-based abstractions), as well as the peer information (peer host and peer port) of each peer that is currently peering a specific dDatabase. dWeb's DHT is what makes the dWeb so distributed and mathematically impossible to take offline. By downloading dWeb-based desktop applications, your computer becomes a `DHT node` and will strategically stores two crucial types of information:

- `Other DHT Nodes` - Stores information regarding other DHT nodes so that it can route requests for a `dweb-key` to the specific DHT node that possesses that `dweb-key` as well as the peers who are peering it.
- `dDatabase/Peer Info` - Stores information regarding a specific set of dDatabases and their peers, determined by various algorithms.

dWeb's DHT is based on the `Kademlia Distributed Hash Table` popularized by BitTorrent and others. Nodes and data in dWeb's DHT are assigned 160-bit integers as IDs and dDatabase/peer data is stored in the form of key-value pairs, where the key is a 64 hexadecimal value generated by hash functions such as SHA-1 (a dWeb key normally) and the value is normally the peer data associated with the key.

An example of this is below:

```
Key                                                        Value
========                                               =======
dweb-key (64 hexadecimal key)               [{peer1 host, peer1 port}, {peer2 host, peer2 port}...]
```

The DHT defines the distance between 2 DHT nodes `i` and `j` by the "bitwise exclusive OR operation" `(XOR)`, i.e. 
`d(i,j) =  i (XOR) j`. This distance means for any given key `l` and a distance `l > 0`, there can only be a single key `j` that satisfies `d(i, j) = l`.

All key-value pairs are stored on `k` nodes whose UIDs are closest to the actual key. `k` is an important parameter that helps determine data redundancy and how stable the DHT is at any given time. Each node `i` always maintains multiple `k`-buckets. Each `k`-bucket stores a list of other DHT nodes, which are organized in an order that reflects the most recently active nodes. The node that is most recently active is stored at the tail, while the least active node is stored at the head. 

The node whose distance from the node `i`, that is in the range of `[pow(2,m), pow(2, m+1)]`, is stored in the `m`th `k`-bucket (node that is 0 < m < 160). The nodes in the `k`-buckets are regarded as the neighbors of the node `i`. A dWeb DHT node dynamically updates its neighbors upon receiving ANY message from them. This process can be better explained more specifically when node `i` receives a message from another DHT node `j`, which is located in the `m`th `k`-bucket where this `k`-bucket of node `i` will be updated in the following way:

- If `j` already exists, in the `k`-bucket, `i` moves `j` to the tail of the list, as node `j` is the most recently seen.
- If `j` is not in the `k`-bucket and the bucket has fewer than `k` nodes, node `i` inserts `j` at the tail of the list.
- If the bucket is full, `i` `PINGS` the node at the head of that particular `k`-bucket.
- If the head node responds, node `i` moves it to the tail and ignores node `j`. 
- Otherwise, `i` removes the head node and inserts `j` at the tail.

## DHT Primitives 
- `PING` - probes a DHT node to check whether it's online or not.
- `STORE` - used to store a key-value pair
- `FIND_NODE` - finds a set of nodes that are closest to a given node.
- `FIND_VALUE` - operates like `FIND_NODE` but returns a stored value

These RPC-like primitives work in a recursive way, which improves the efficiency of dWeb's DHT. A `lookup` procedure is initiated by the `FIND_NODE` and `FIND_VALUE` primitives, where the lookup initiator choose (B) nodes from its closest `k`-buckets and sends many parallel `FIND_NODE` requests to these (B) nodes. If the node being searched for in a given iteration is not found, the lookup initiator re-sends `FIND_NODE` to the nodes that were found during the previous recursive operation and repeats this until it finds what it's looking for.

A key-value pair may be stored on multiple DHT nodes. Thanks to the recursive procedure explained above, the key-value pair spreads across the DHT network every hour. This process insures that multiple replicas of data exists across the network itself. Every key-value pair is deleted 24 hours after it is initially pushed into the network.

## Joining and Leaving
When node `i` joins dWeb's DHT, it is assumed that it is aware of or knows about node `j`. The joining process consists of multiple steps as follows:
1. Node `i` inserts `j` into its `k`-buckets.
2. Node `i` starts a node lookup procedure for its own ID, where `i` is made aware of other newer nodes.
3. Node `i` updates the `k`-buckets.

During this process, node `i` strengthens its `k`-buckets and inserts itself into other node's `k`-buckets. When other nodes leave or fail, they DO NOT notify other nodes. There is no need for a special procedure to cope with node departures, as these mechanisms insure that leaving nodes will be removed from the `k`-buckets.

## Having Trouble?
If you're facing issues, please join our [Peeps Labs Telegram](https://t.me/peepslabs) where our community's developers can help you figure things out!

## What's Next?
Learn about Peer Discovery and how data is downloaded from them in parallel.

[Click here to continue](peer-discovery.md)